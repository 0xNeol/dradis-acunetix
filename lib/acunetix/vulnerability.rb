module Acunetix
  class Vulnerability
    include ::Cleanup

    attr_accessor :xml

    # Accepts an XML node from Nokogiri::XML.
    def initialize(xml_node)
      @xml = xml_node
    end

    def supported_tags
      [
        # Vulnerability fields
        :name, :type, :url, :description, :impact, :remedial_actions,
        :exploitation_skills, :remedial_procedure, :remedy_references,
        :external_references, :severity, :certainty, :confirmed, :state, :owasp,
        :wasc, :cwe, :capec, :pci32, :hipaa, :owasppc, :iso27001,
        :cvss_vector, :cvss_base, :cvss_temporal, :cvss_environmental,
        :cvss31_vector, :cvss31_base, :cvss31_temporal, :cvss31_environmental,

        # Evidence fields
        :http_request, :http_request_method,
        :http_response, :http_response_status_code, :http_response_duration
      ]
    end

    # This allows external callers (and specs) to check for implemented
    # properties
    def respond_to?(method, include_private=false)
      return true if supported_tags.include?(method.to_sym)
      super
    end

    # This method is invoked by Ruby when a method that is not defined in this
    # instance is called.
    #
    # In our case we inspect the @method@ parameter and try to find the
    # attribute, simple descendent or collection that it maps to in the XML
    # tree.
    def method_missing(method, *args)
      # We could remove this check and return nil for any non-recognized tag.
      # The problem would be that it would make tricky to debug problems with
      # typos. For instance: <>.potr would return nil instead of raising an
      # exception
      unless supported_tags.include?(method)
        super
        return
      end

      translations_table = vulnerability_table.merge(evidence_table)

      method_name = translations_table.fetch(method, method.to_s.dasherize)

      # then we try the children tags
      tag = xml.at_xpath("./#{method_name}")
      if tag && !tag.text.blank?
        if tags_with_html_content.include?(method)
          return cleanup_html(tag.text)
        else
          return tag.text
        end
      else
        'n/a'
      end

      # nothing found
      return nil
    end

    private

    # Define a hash to get the actual XPATH operator we will use to
    # find the field value, given a field name.
    def vulnerability_table
      owasp_fields = [
        :owasp, :wasc, :cwe, :capec, :pci32, :hipaa, :owasppc, :iso27001
      ]
      vulnerability_table = {
        cvss_vector: 'cvss/vector',
        cvss_base: 'cvss/score/type[. = "Base"]/following::value',
        cvss_temporal: 'cvss/score/type[. = "Temporal"]/following::value',
        cvss_environmental: 'cvss/score/type[. = "Environmental"]/following::value',
        cvss31_vector: 'cvss31/vector',
        cvss31_base: 'cvss31/score/type[. = "Base"]/following::value',
        cvss31_temporal: 'cvss31/score/type[. = "Temporal"]/following::value',
        cvss31_environmental: 'cvss31/score/type[. = "Environmental"]/following::value',
      }

      vulnerability_table.merge! Hash[owasp_fields.map { |field| [field, field.to_s] }]

      # Append the 'classifications' parent to each translated field name
      vulnerability_table.each do |_, value|
        value.replace("classification/#{value}")
      end

      vulnerability_table
    end

    def evidence_table
      {
        http_request: 'http-request/content',
        http_request_method: 'http-request/method',
        http_response: 'http-response/content',
        http_response_status_code: 'http-response/status-code',
        http_response_duration: 'http-response/duration'
      }
    end
  end
end
